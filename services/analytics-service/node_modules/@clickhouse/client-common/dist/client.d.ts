import type { ClickHouseLogLevel, ClickHouseSettings, Connection, ConnectionParams, ConnExecResult, Logger, WithClickHouseSummary } from '@clickhouse/client-common';
import { type DataFormat } from '@clickhouse/client-common';
import type { InputJSON, InputJSONObjectEachRow } from './clickhouse_types';
import type { ConnPingResult } from './connection';
import type { BaseResultSet } from './result';
export type MakeConnection<Stream> = (params: ConnectionParams) => Connection<Stream>;
export type MakeResultSet<Stream> = (stream: Stream, format: DataFormat, session_id: string) => BaseResultSet<Stream>;
export interface ValuesEncoder<Stream> {
    validateInsertValues<T = unknown>(values: InsertValues<Stream, T>, format: DataFormat): void;
    /**
     * A function encodes an array or a stream of JSON objects to a format compatible with ClickHouse.
     * If values are provided as an array of JSON objects, the function encodes it in place.
     * If values are provided as a stream of JSON objects, the function sets up the encoding of each chunk.
     * If values are provided as a raw non-object stream, the function does nothing.
     *
     * @param values a set of values to send to ClickHouse.
     * @param format a format to encode value to.
     */
    encodeValues<T = unknown>(values: InsertValues<Stream, T>, format: DataFormat): string | Stream;
}
export type CloseStream<Stream> = (stream: Stream) => Promise<void>;
export interface ClickHouseClientConfigOptions<Stream> {
    impl: {
        make_connection: MakeConnection<Stream>;
        make_result_set: MakeResultSet<Stream>;
        values_encoder: ValuesEncoder<Stream>;
        close_stream: CloseStream<Stream>;
    };
    /** A ClickHouse instance URL. Default value: `http://localhost:8123`. */
    host?: string;
    /** The request timeout in milliseconds. Default value: `30_000`. */
    request_timeout?: number;
    /** Maximum number of sockets to allow per host. Default value: `Infinity`. */
    max_open_connections?: number;
    compression?: {
        /** `response: true` instructs ClickHouse server to respond with
         * compressed response body. Default: true. */
        response?: boolean;
        /** `request: true` enabled compression on the client request body.
         * Default: false. */
        request?: boolean;
    };
    /** The name of the user on whose behalf requests are made.
     * Default: 'default'. */
    username?: string;
    /** The user password. Default: ''. */
    password?: string;
    /** The name of the application using the JS client.
     * Default: empty. */
    application?: string;
    /** Database name to use. Default value: `default`. */
    database?: string;
    /** ClickHouse settings to apply to all requests. Default value: {} */
    clickhouse_settings?: ClickHouseSettings;
    log?: {
        /** A class to instantiate a custom logger implementation.
         * Default: {@link DefaultLogger} */
        LoggerClass?: new () => Logger;
        /** Default: OFF */
        level?: ClickHouseLogLevel;
    };
    session_id?: string;
    additional_headers?: Record<string, string>;
}
export type BaseClickHouseClientConfigOptions<Stream> = Omit<ClickHouseClientConfigOptions<Stream>, 'impl'>;
export interface BaseQueryParams {
    /** ClickHouse's settings that can be applied on query level. */
    clickhouse_settings?: ClickHouseSettings;
    /** Parameters for query binding. https://clickhouse.com/docs/en/interfaces/http/#cli-queries-with-parameters */
    query_params?: Record<string, unknown>;
    /** AbortSignal instance to cancel a request in progress. */
    abort_signal?: AbortSignal;
    /** A specific `query_id` that will be sent with this request.
     * If it is not set, a random identifier will be generated automatically by the client. */
    query_id?: string;
    session_id?: string;
}
export interface QueryParams extends BaseQueryParams {
    /** Statement to execute. */
    query: string;
    /** Format of the resulting dataset. */
    format?: DataFormat;
}
export interface ExecParams extends BaseQueryParams {
    /** Statement to execute. */
    query: string;
}
export type CommandParams = ExecParams;
export type CommandResult = {
    query_id: string;
} & WithClickHouseSummary;
export type InsertResult = {
    /**
     * Indicates whether the INSERT statement was executed on the server.
     * Will be `false` if there was no data to insert.
     * For example: if {@link InsertParams.values} was an empty array,
     * the client does not any requests to the server, and {@link executed} is false.
     */
    executed: boolean;
    /**
     * Empty string if {@link executed} is false.
     * Otherwise, either {@link InsertParams.query_id} if it was set, or the id that was generated by the client.
     */
    query_id: string;
} & WithClickHouseSummary;
export type ExecResult<Stream> = ConnExecResult<Stream>;
export type PingResult = ConnPingResult;
export type InsertValues<Stream, T = unknown> = ReadonlyArray<T> | Stream | InputJSON<T> | InputJSONObjectEachRow<T>;
type NonEmptyArray<T> = [T, ...T[]];
/** {@link except} field contains a non-empty list of columns to exclude when generating `(* EXCEPT (...))` clause */
export interface InsertColumnsExcept {
    except: NonEmptyArray<string>;
}
export interface InsertParams<Stream = unknown, T = unknown> extends BaseQueryParams {
    /** Name of a table to insert into. */
    table: string;
    /** A dataset to insert. */
    values: InsertValues<Stream, T>;
    /** Format of the dataset to insert. Default: `JSONCompactEachRow` */
    format?: DataFormat;
    /**
     * Allows to specify which columns the data will be inserted into.
     * Accepts either an array of strings (column names) or an object of {@link InsertColumnsExcept} type.
     * Examples of generated queries:
     *
     * - An array such as `['a', 'b']` will generate: `INSERT INTO table (a, b) FORMAT DataFormat`
     * - An object such as `{ except: ['a', 'b'] }` will generate: `INSERT INTO table (* EXCEPT (a, b)) FORMAT DataFormat`
     *
     * By default, the data is inserted into all columns of the {@link InsertParams.table},
     * and the generated statement will be: `INSERT INTO table FORMAT DataFormat`.
     *
     * See also: https://clickhouse.com/docs/en/sql-reference/statements/insert-into */
    columns?: NonEmptyArray<string> | InsertColumnsExcept;
}
export declare class ClickHouseClient<Stream = unknown> {
    private readonly connectionParams;
    private readonly connection;
    private readonly makeResultSet;
    private readonly valuesEncoder;
    private readonly closeStream;
    private readonly sessionId?;
    constructor(config: ClickHouseClientConfigOptions<Stream>);
    private getQueryParams;
    /**
     * Used for most statements that can have a response, such as SELECT.
     * FORMAT clause should be specified separately via {@link QueryParams.format} (default is JSON)
     * Consider using {@link ClickHouseClient.insert} for data insertion,
     * or {@link ClickHouseClient.command} for DDLs.
     */
    query(params: QueryParams): Promise<BaseResultSet<Stream>>;
    /**
     * It should be used for statements that do not have any output,
     * when the format clause is not applicable, or when you are not interested in the response at all.
     * Response stream is destroyed immediately as we do not expect useful information there.
     * Examples of such statements are DDLs or custom inserts.
     * If you are interested in the response data, consider using {@link ClickHouseClient.exec}
     */
    command(params: CommandParams): Promise<CommandResult>;
    /**
     * Similar to {@link ClickHouseClient.command}, but for the cases where the output is expected,
     * but format clause is not applicable. The caller of this method is expected to consume the stream,
     * otherwise, the request will eventually be timed out.
     */
    exec(params: ExecParams): Promise<ExecResult<Stream>>;
    /**
     * The primary method for data insertion. It is recommended to avoid arrays in case of large inserts
     * to reduce application memory consumption and consider streaming for most of such use cases.
     * As the insert operation does not provide any output, the response stream is immediately destroyed.
     * In case of a custom insert operation, such as, for example, INSERT FROM SELECT,
     * consider using {@link ClickHouseClient.command}, passing the entire raw query there (including FORMAT clause).
     */
    insert<T>(params: InsertParams<Stream, T>): Promise<InsertResult>;
    /**
     * Health-check request. It does not throw if an error occurs -
     * the error is returned inside the result object.
     */
    ping(): Promise<PingResult>;
    /**
     * Shuts down the underlying connection.
     * This method should ideally be called only once per application lifecycle,
     * for example, during the graceful shutdown phase.
     */
    close(): Promise<void>;
}
export {};
