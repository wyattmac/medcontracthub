{"version":3,"file":"event-processor.js","sourceRoot":"","sources":["../../src/processors/event-processor.ts"],"names":[],"mappings":"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","sourcesContent":["import { ClickHouseWriter } from '../writers/clickhouse-writer';\nimport { logger } from '../utils/logger';\nimport { MetricsCollector } from '../monitoring/metrics';\n\nexport class EventProcessor {\n  private clickhouseWriter: ClickHouseWriter;\n  private metrics: MetricsCollector;\n  private eventHandlers: Map<string, (event: any) => Promise<void>>;\n\n  constructor(clickhouseWriter: ClickHouseWriter) {\n    this.clickhouseWriter = clickhouseWriter;\n    this.metrics = MetricsCollector.getInstance();\n    \n    // Register event handlers\n    this.eventHandlers = new Map([\n      ['contracts.opportunity.viewed', this.handleOpportunityViewed.bind(this)],\n      ['contracts.opportunity.saved', this.handleOpportunitySaved.bind(this)],\n      ['contracts.proposal.created', this.handleProposalCreated.bind(this)],\n      ['contracts.proposal.updated', this.handleProposalUpdated.bind(this)],\n      ['ai.document.processed', this.handleDocumentProcessed.bind(this)],\n      ['user.activity', this.handleUserActivity.bind(this)],\n    ]);\n  }\n\n  async processEvent(topic: string, event: any): Promise<void> {\n    const handler = this.eventHandlers.get(topic);\n    \n    if (!handler) {\n      logger.warn(`No handler registered for topic: ${topic}`);\n      this.metrics.incrementCounter('events_unhandled_total', { topic });\n      return;\n    }\n\n    try {\n      await handler(event);\n      this.metrics.incrementCounter('events_processed_total', { topic, status: 'success' });\n    } catch (error) {\n      logger.error(`Error processing event from topic ${topic}:`, error);\n      this.metrics.incrementCounter('events_processed_total', { topic, status: 'error' });\n      throw error;\n    }\n  }\n\n  private async handleOpportunityViewed(event: any): Promise<void> {\n    // Write to raw events table\n    await this.clickhouseWriter.writeOpportunityViewedEvent(event);\n    \n    // Update real-time aggregations\n    await this.updateViewAggregations(event);\n    \n    // Check for anomalies\n    await this.detectViewAnomalies(event);\n  }\n\n  private async handleOpportunitySaved(event: any): Promise<void> {\n    // Write to saves table\n    await this.clickhouseWriter.writeOpportunitySavedEvent(event);\n    \n    // Update user engagement metrics\n    await this.updateEngagementMetrics(event);\n    \n    // Calculate conversion funnel\n    await this.updateConversionFunnel(event);\n  }\n\n  private async handleProposalCreated(event: any): Promise<void> {\n    // Implementation for proposal created events\n    logger.info('Processing proposal created event', { eventId: event.eventId });\n  }\n\n  private async handleProposalUpdated(event: any): Promise<void> {\n    // Implementation for proposal updated events\n    logger.info('Processing proposal updated event', { eventId: event.eventId });\n  }\n\n  private async handleDocumentProcessed(event: any): Promise<void> {\n    // Implementation for document processed events\n    logger.info('Processing document processed event', { eventId: event.eventId });\n  }\n\n  private async handleUserActivity(event: any): Promise<void> {\n    // Implementation for user activity events\n    logger.info('Processing user activity event', { eventId: event.eventId });\n  }\n\n  private async updateViewAggregations(event: any): Promise<void> {\n    // In production, update materialized views or aggregation tables\n    // For now, just track metrics\n    this.metrics.incrementCounter('opportunity_views_total', {\n      agency: event.opportunityMetadata.agency,\n      source: event.viewContext.source,\n    });\n  }\n\n  private async detectViewAnomalies(event: any): Promise<void> {\n    // Simple anomaly detection - in production, use ML models\n    const viewsInLastMinute = await this.getRecentViewCount(event.userId);\n    \n    if (viewsInLastMinute > 100) {\n      logger.warn('Potential view anomaly detected', {\n        userId: event.userId,\n        viewsInLastMinute,\n      });\n      \n      this.metrics.incrementCounter('anomalies_detected_total', {\n        type: 'excessive_views',\n      });\n    }\n  }\n\n  private async updateEngagementMetrics(event: any): Promise<void> {\n    // Track save-to-view ratio and other engagement metrics\n    this.metrics.incrementCounter('opportunity_saves_total', {\n      agency: event.opportunityMetadata.agency,\n      source: event.saveContext.source,\n    });\n  }\n\n  private async updateConversionFunnel(event: any): Promise<void> {\n    // Track conversion through the funnel\n    this.metrics.recordGauge('conversion_funnel', 1, {\n      stage: 'saved',\n      source: event.saveContext.source,\n    });\n  }\n\n  private async getRecentViewCount(_userId: string): Promise<number> {\n    // In production, query ClickHouse or use Redis cache\n    // For now, return a mock value\n    return 5;\n  }\n\n  async flush(): Promise<void> {\n    await this.clickhouseWriter.flush();\n  }\n}"]}